<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>0xRIP — Monument</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #fafafa;
      --bg-secondary: #f0f0f0;
      --bg-tertiary: #e8e8e8;
      --text-primary: #1a1a1a;
      --text-secondary: #666666;
      --text-muted: #999999;
      --accent: #333333;
      --shadow: rgba(0, 0, 0, 0.08);
      --shadow-heavy: rgba(0, 0, 0, 0.15);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      font-family: 'Cormorant Garamond', Georgia, serif;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* 微妙的噪点纹理 */
    #canvas-container::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 1;
    }

    /* 顶部标题 */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 40px 60px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      z-index: 100;
      pointer-events: none;
    }

    .brand {
      pointer-events: auto;
    }

    .brand-title {
      font-size: 14px;
      font-family: 'Space Mono', monospace;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .brand-subtitle {
      font-size: 32px;
      font-weight: 300;
      letter-spacing: -0.02em;
      color: var(--text-primary);
      font-style: italic;
    }

    .mode-toggle {
      pointer-events: auto;
      padding: 12px 24px;
      background: transparent;
      border: 1px solid var(--text-secondary);
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mode-toggle:hover {
      background: var(--text-primary);
      border-color: var(--text-primary);
      color: var(--bg-primary);
    }

    /* 底部信息 */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 40px 60px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      z-index: 100;
      pointer-events: none;
    }

    .instructions {
      font-size: 13px;
      color: var(--text-muted);
      letter-spacing: 0.05em;
      pointer-events: auto;
    }

    .instructions span {
      display: inline-block;
      margin-right: 24px;
      position: relative;
    }

    .instructions span::after {
      content: '•';
      position: absolute;
      right: -16px;
      color: var(--text-muted);
    }

    .instructions span:last-child::after {
      display: none;
    }

    .grave-count {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .grave-count .number {
      font-size: 24px;
      color: var(--text-primary);
      display: block;
      margin-top: 4px;
    }

    /* 加载动画 */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 1px solid var(--bg-tertiary);
      border-top-color: var(--text-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    /* 墓碑详情浮层 */
    .grave-tooltip {
      position: fixed;
      padding: 20px 24px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--bg-tertiary);
      box-shadow: 0 20px 60px var(--shadow);
      pointer-events: none;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 50;
      min-width: 200px;
    }

    .grave-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .grave-tooltip-id {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.15em;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .grave-tooltip-name {
      font-size: 20px;
      font-weight: 400;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .grave-tooltip-date {
      font-size: 13px;
      color: var(--text-secondary);
      font-style: italic;
    }

    /* 淡入动画 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .fade-in {
      animation: fadeIn 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      opacity: 0;
    }

    .delay-1 { animation-delay: 0.1s; }
    .delay-2 { animation-delay: 0.2s; }
    .delay-3 { animation-delay: 0.3s; }
  </style>
</head>
<body>
  <div class="header">
    <div class="brand fade-in">
      <div class="brand-title">0xRIP</div>
      <div class="brand-subtitle">A digital memorial</div>
    </div>
    <button class="mode-toggle fade-in delay-1" id="modeToggle">Switch to Cyber Mode</button>
  </div>

  <div class="footer">
    <div class="instructions fade-in delay-2">
      <span>Click ground to move</span>
      <span>Drag to rotate</span>
      <span>Click monument to interact</span>
    </div>
    <div class="grave-count fade-in delay-3">
      Monuments
      <span class="number" id="graveCount">04</span>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading</div>
  </div>

  <div class="grave-tooltip" id="tooltip">
    <div class="grave-tooltip-id" id="tooltipId">0x0000</div>
    <div class="grave-tooltip-name" id="tooltipName">Name</div>
    <div class="grave-tooltip-date" id="tooltipDate">Date</div>
  </div>

  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================
    // 灰白色纪念碑谷风格 — 精制版
    // ============================================

    const Colors = {
      white: 0xffffff,
      lightGray: 0xf5f5f5,
      midGray: 0xd0d0d0,
      darkGray: 0x808080,
      charcoal: 0x404040,
      black: 0x1a1a1a,
    };

    let scene, camera, renderer, controls;
    let raycaster, mouse;
    let graves = [];
    let ghost;
    let hoveredGrave = null;

    // 墓碑数据
    const graveData = [
      { x: -6, z: -6, height: 4, name: 'Memory of Spring', date: '2024.03.15' },
      { x: 6, z: -4, height: 3, name: 'The Last Conversation', date: '2024.06.22' },
      { x: -3, z: 6, height: 5, name: 'Unsent Letters', date: '2024.09.08' },
      { x: 4, z: 5, height: 3.5, name: 'Digital Echo', date: '2024.11.30' },
    ];

    function init() {
      const container = document.getElementById('canvas-container');
      document.getElementById('loading').style.display = 'none';

      // 场景 - 纯净灰白
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xfafafa);

      // 正交相机
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
      camera.position.set(20, 20, 20);
      camera.lookAt(0, 0, 0);

      // 渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // 控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minZoom = 0.6;
      controls.maxZoom = 1.8;
      controls.maxPolarAngle = Math.PI / 2.1;

      setupLighting();
      createEnvironment();
      createGraves();
      createGhost();
      createParticles();

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      animate();
    }

    function setupLighting() {
      // 环境光 - 柔和均匀
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      // 主光源 - 模拟自然光
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
      sunLight.position.set(15, 30, 10);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 4096;
      sunLight.shadow.mapSize.height = 4096;
      sunLight.shadow.camera.near = 0.1;
      sunLight.shadow.camera.far = 200;
      sunLight.shadow.camera.left = -50;
      sunLight.shadow.camera.right = 50;
      sunLight.shadow.camera.top = 50;
      sunLight.shadow.camera.bottom = -50;
      sunLight.shadow.radius = 8;
      sunLight.shadow.bias = -0.0001;
      scene.add(sunLight);

      // 补光 - 来自下方，增加立体感
      const fillLight = new THREE.DirectionalLight(0xf0f0f0, 0.3);
      fillLight.position.set(-10, 5, -10);
      scene.add(fillLight);
    }

    function createEnvironment() {
      // 主地面 - 极简圆形平台
      const groundGeo = new THREE.CylinderGeometry(22, 22, 0.5, 64);
      const groundMat = new THREE.MeshLambertMaterial({
        color: Colors.white,
        flatShading: false,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.position.y = -0.25;
      ground.receiveShadow = true;
      scene.add(ground);

      // 次地面 - 稍大的阴影层
      const shadowGroundGeo = new THREE.CylinderGeometry(24, 24, 0.1, 64);
      const shadowGroundMat = new THREE.MeshBasicMaterial({
        color: 0xf0f0f0,
      });
      const shadowGround = new THREE.Mesh(shadowGroundGeo, shadowGroundMat);
      shadowGround.position.y = -0.6;
      scene.add(shadowGround);

      // 装饰性几何体 - 作为路标
      const markers = [
        { x: -12, z: -12, h: 1 },
        { x: 12, z: -10, h: 0.8 },
        { x: -8, z: 12, h: 1.2 },
      ];

      markers.forEach(m => {
        const geo = new THREE.CylinderGeometry(0.3, 0.4, m.h, 6);
        const mat = new THREE.MeshLambertMaterial({
          color: Colors.lightGray,
          flatShading: true,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(m.x, m.h / 2, m.z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
      });
    }

    function createGraves() {
      graveData.forEach((data, index) => {
        const group = new THREE.Group();
        group.position.set(data.x, data.height / 2, data.z);

        // 主体 - 简洁的白色方柱
        const bodyGeo = new THREE.BoxGeometry(2.2, data.height, 2.2);
        const bodyMat = new THREE.MeshLambertMaterial({
          color: Colors.white,
          flatShading: false,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);

        // 顶部 - 深色盖子，增加对比
        const topGeo = new THREE.CylinderGeometry(1.3, 1.5, 0.4, 8);
        const topMat = new THREE.MeshLambertMaterial({
          color: Colors.charcoal,
          flatShading: true,
        });
        const top = new THREE.Mesh(topGeo, topMat);
        top.position.y = data.height / 2 + 0.2;
        top.castShadow = true;
        group.add(top);

        // 底部阴影环
        const shadowGeo = new THREE.RingGeometry(1.8, 2.8, 32);
        const shadowMat = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.06,
        });
        const shadowRing = new THREE.Mesh(shadowGeo, shadowMat);
        shadowRing.rotation.x = -Math.PI / 2;
        shadowRing.position.y = -data.height / 2 + 0.01;
        group.add(shadowRing);

        // 存储数据
        group.userData = {
          type: 'grave',
          id: `0x${(1000 + index).toString(16).toUpperCase()}`,
          name: data.name,
          date: data.date,
          originalY: data.height / 2,
          baseHeight: data.height,
        };

        graves.push(group);
        scene.add(group);

        // 优雅入场动画
        group.scale.set(0, 0, 0);
        animateScale(group, 1, 1200 + index * 150);
      });
    }

    function createGhost() {
      const group = new THREE.Group();

      // 核心 - 精致的二十面体
      const coreGeo = new THREE.IcosahedronGeometry(0.5, 1);
      const coreMat = new THREE.MeshLambertMaterial({
        color: Colors.darkGray,
        flatShading: true,
        transparent: true,
        opacity: 0.9,
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      group.add(core);

      // 内层光晕
      const innerGlowGeo = new THREE.IcosahedronGeometry(0.8, 1);
      const innerGlowMat = new THREE.MeshBasicMaterial({
        color: Colors.midGray,
        transparent: true,
        opacity: 0.15,
      });
      const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
      group.add(innerGlow);

      // 外层光晕
      const outerGlowGeo = new THREE.IcosahedronGeometry(1.3, 2);
      const outerGlowMat = new THREE.MeshBasicMaterial({
        color: Colors.lightGray,
        transparent: true,
        opacity: 0.08,
      });
      const outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
      group.add(outerGlow);

      group.position.set(0, 2.5, 0);
      ghost = group;
      scene.add(ghost);
    }

    function createParticles() {
      // 浮动微粒 - 增加氛围
      const particleCount = 30;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const speeds = [];

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 40;
        positions[i * 3 + 1] = Math.random() * 15;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
        speeds.push({
          y: 0.005 + Math.random() * 0.01,
          x: (Math.random() - 0.5) * 0.002,
          z: (Math.random() - 0.5) * 0.002,
        });
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        color: Colors.midGray,
        size: 0.08,
        transparent: true,
        opacity: 0.6,
      });

      const particles = new THREE.Points(geometry, material);
      particles.userData = { speeds };
      scene.add(particles);

      // 动画函数
      particles.userData.animate = () => {
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += speeds[i].x;
          positions[i * 3 + 1] += speeds[i].y;
          positions[i * 3 + 2] += speeds[i].z;

          if (positions[i * 3 + 1] > 15) {
            positions[i * 3 + 1] = 0;
          }
        }
        particles.geometry.attributes.position.needsUpdate = true;
      };
    }

    function animateScale(object, target, duration) {
      const start = object.scale.x;
      const startTime = Date.now();

      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 4);

        const current = start + (target - start) * eased;
        object.scale.set(current, current, current);

        if (progress < 1) requestAnimationFrame(update);
      }

      update();
    }

    function moveGhostTo(targetPos) {
      const startPos = ghost.position.clone();
      const duration = 1500;
      const startTime = Date.now();

      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);

        ghost.position.lerpVectors(startPos, targetPos, eased);
        ghost.position.y = targetPos.y + Math.sin(progress * Math.PI) * 1.5;

        if (progress < 1) requestAnimationFrame(update);
      }

      update();
    }

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const graveMeshes = graves.map(g => g.children[0]);
      const intersects = raycaster.intersectObjects(graveMeshes);

      if (intersects.length > 0) {
        const graveGroup = intersects[0].object.parent;
        const data = graveGroup.userData;

        // 墓碑轻触反馈
        animateGraveHover(graveGroup, data.originalY + 0.3, 250);
        setTimeout(() => animateGraveHover(graveGroup, data.originalY, 400), 300);

        // 幽灵移动
        const targetPos = new THREE.Vector3(
          graveGroup.position.x,
          2.5,
          graveGroup.position.z + 3.5
        );
        moveGhostTo(targetPos);
      } else {
        const groundIntersects = raycaster.intersectObjects(scene.children.filter(
          c => c.geometry && c.geometry.type === 'CylinderGeometry'
        ));

        if (groundIntersects.length > 0) {
          const point = groundIntersects[0].point;
          moveGhostTo(new THREE.Vector3(point.x, 2.5, point.z));
        }
      }
    }

    function animateGraveHover(grave, targetY, duration) {
      const startY = grave.position.y;
      const startTime = Date.now();

      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);

        grave.position.y = startY + (targetY - startY) * eased;

        if (progress < 1) requestAnimationFrame(update);
      }

      update();
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const graveMeshes = graves.map(g => g.children[0]);
      const intersects = raycaster.intersectObjects(graveMeshes);

      const tooltip = document.getElementById('tooltip');

      if (intersects.length > 0) {
        const graveGroup = intersects[0].object.parent;
        const data = graveGroup.userData;

        if (hoveredGrave !== graveGroup) {
          hoveredGrave = graveGroup;
          document.body.style.cursor = 'pointer';

          // 更新 tooltip
          document.getElementById('tooltipId').textContent = data.id;
          document.getElementById('tooltipName').textContent = data.name;
          document.getElementById('tooltipDate').textContent = data.date;

          // 轻微上浮
          animateGraveHover(graveGroup, data.originalY + 0.15, 200);
        }

        // 跟随鼠标
        tooltip.style.left = (event.clientX + 20) + 'px';
        tooltip.style.top = (event.clientY - 60) + 'px';
        tooltip.classList.add('visible');
      } else {
        if (hoveredGrave) {
          animateGraveHover(hoveredGrave, hoveredGrave.userData.originalY, 200);
          hoveredGrave = null;
        }
        document.body.style.cursor = 'default';
        tooltip.classList.remove('visible');
      }
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;

      camera.left = -d * aspect;
      camera.right = d * aspect;
      camera.top = d;
      camera.bottom = -d;

      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // 幽灵漂浮
      if (ghost) {
        ghost.position.y = 2.5 + Math.sin(time * 0.8) * 0.2;
        ghost.rotation.y = Math.sin(time * 0.3) * 0.05;
        ghost.children[1].rotation.y -= 0.005;
        ghost.children[2].rotation.y += 0.003;
      }

      // 微粒动画
      scene.children.forEach(child => {
        if (child.userData && child.userData.animate) {
          child.userData.animate();
        }
      });

      // 墓碑轻微呼吸
      graves.forEach((grave, i) => {
        const top = grave.children[1];
        if (top) {
          const breathe = 1 + Math.sin(time * 0.5 + i * 0.5) * 0.02;
          top.scale.set(breathe, 1, breathe);
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }

    document.getElementById('modeToggle').addEventListener('click', () => {
      alert('Switching to CYBER NECROPOLIS mode...');
    });

    init();
  </script>
</body>
</html>
